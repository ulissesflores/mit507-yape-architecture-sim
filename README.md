# ğŸ¦ Yape Architecture Simulation: Monolith vs. Cell-Based

[![License](https://img.shields.io/badge/License-Apache%202.0-blue.svg)](https://opensource.org/licenses/Apache-2.0)
[![DOI](https://zenodo.org/badge/DOI/10.5281/zenodo.18641336.svg)](https://doi.org/10.5281/zenodo.18641336)
[![Python](https://img.shields.io/badge/Python-3.12-3776AB?logo=python&logoColor=white)](https://www.python.org/)
[![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/ulissesflores/mit507-yape-architecture-sim/blob/main/notebooks/simulation_analysis.ipynb)

> **Architectural validation for high-frequency FinTech systems.**

## ğŸ“‹ Overview

This repository contains the scientific artifacts supporting the case study **"Yape: From Monolith to Cell-Based Architecture"**. 

Developed by **Carlos Ulisses Flores** for the MIT-507 (Digital Organization) course, this project uses Discrete Event Simulation (DES) to mathematically prove why legacy banking architectures fail under "Black Friday" loads and how **Cell-Based Architectures (Bulkheads)** provide infinite horizontal scalability.

## ğŸ§ª The Experiment

This repository simulates two architectural regimes under identical traffic:
a single **monolith** with a shared connection pool, and a **cell-based**
architecture in which shards are independently processed by per-cell workers.

### ACK variability model (cell-based)

In the cell-based regime, the client-observable latency is the **ingress ACK**
(i.e., acknowledgement after asynchronous handoff). In production systems this ACK
is rarely deterministic; it typically exhibits:

- **micro-jitter** (network jitter, enqueue/dequeue variability, short CPU contention),
- **load-coupled drift** (backpressure as queues grow), and
- **rare tail spikes** (transient retries, GC pauses, kernel scheduling anomalies).

To capture these effects without overfitting, the simulator uses an explicit and
reproducible mixture model:

\[
	ext{ack}_{ms} = b \cdot \mathrm{LogNormal}(\mu=-	frac{1}{2}\sigma^2,\ \sigma)
+ \mathcal{N}(0,\ s)
+ q \cdot k
+ \mathbb{I}_{tail}\cdot \mathrm{LogNormal}(\mu_t,\ \sigma_t)
\]

Where:
- \(b\) is `event_bus_ack_ms` (baseline ACK),
- \(\sigma\) is `event_bus_ack_jitter_lognorm_sigma` (multiplicative jitter),
- \(s\) is `event_bus_ack_additive_std_ms` (additive jitter),
- \(q\) is the target cell backlog snapshot, with slope \(k\) = `event_bus_ack_backlog_scale_ms`,
- \(\mathbb{I}_{tail}\sim\mathrm{Bernoulli}(p)\) with \(p\) = `event_bus_ack_tail_prob`,
  and the spike parameters \((\mu_t,\sigma_t)\) are
  (`event_bus_ack_tail_lognorm_mu`, `event_bus_ack_tail_lognorm_sigma`).

All parameters are recorded in `experiment_provenance.json` when running the notebook.


We simulate two distinct architectural patterns under stress conditions (500 TPS):

1.  **AS-IS (Monolithic/Legacy):** A system with a shared `PostgreSQL` resource. Validates the "Hollow Core" problem where database locks cause cascading latency.
2.  **TO-BE (Cell-Based/Event-Driven):** A system sharded into 10 independent `Cells`, using `Kafka` for asynchronous ingestion. Validates **Little's Law** ($L = \lambda W$) applied to throughput.

## ğŸ“‚ Repository Structure
```text
mit507-yape-architecture-sim/
â”œâ”€â”€ src/
â”‚   â””â”€â”€ simulation.py       # Core SimPy logic (Discrete Event Simulation)
â”œâ”€â”€ notebooks/
â”‚   â””â”€â”€ analysis.ipynb      # Jupyter Notebook for results visualization
â”œâ”€â”€ data/
â”‚   â””â”€â”€ logs/               # Synthetic logs generated by the simulation
â”œâ”€â”€ requirements.txt        # Project dependencies (Reproducibility)
â”œâ”€â”€ CITATION.cff            # Academic citation metadata
â””â”€â”€ LICENSE                 # Apache 2.0 License
```

## ğŸš€ Quick Start

### Option A: Cloud (Google Colab)
Click the **"Open in Colab"** badge above to run the simulation in your browser without installation.

### Option B: Local Execution
```bash
# 1. Clone
git clone [https://github.com/ulissesflores/mit507-yape-architecture-sim.git](https://github.com/ulissesflores/mit507-yape-architecture-sim.git)
cd mit507-yape-architecture-sim

# 2. Install
pip install -r requirements.txt

# 3. Run
python src/simulation.py
```

### ğŸ“Š Results & Hypothesis

The simulation demonstrates that under high load ($\lambda > \mu$):

* **Monolith:** Latency grows exponentially as queue size increases (blocking I/O).
* **Cell-Based:** Latency remains constant for the user (async ACK), while backend throughput scales linearly with the number of cells.

## ğŸ“œ License
This project is licensed under the Apache License 2.0 - see the LICENSE file for details.

## âœï¸ Citation
If you use this software in your research, please cite it using the metadata in CITATION.cff.